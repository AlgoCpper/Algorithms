## 재귀
가장 처음 떠올린 것은 dp였으나 dp로는 구현하지 못할 것 같아 다음과 같이 재귀로 작성했다.
```
void func(int num, int l) {
    if (l + 1 >= n) return;

    for (int i = l + 1; i < n; i++) {
        vis[num + a[i]] = true;
        func(num + a[i], i);
    }
}
```
그러나 메모리 제한을 넘기지 못했다. 스택에 재귀함수가 너무 많이 쌓여서 그런 것 같다.
태그를 보니 정렬, 그리디였고 해결할 수 없을 것 같아 풀이를 보았다.

## 그리디
1부터 a 까지의 무게를 측정할 수 있다고 하자. 이 때 무게가 b인 추를 추가한다면 1 + b부터 a + b까지의 무게를 측정할 수 있다.     
이 때 1 + b가 a보다 작거나 같다면 범위를 합쳐 1부터 a + b까지의 무게를 측정할 수 있다고 말할 수 있다.   
반대로 1 + b가 a보다 크다면 a + 1이 측정할 수 없는 최소 무게인 것이다.  
<br/> 
ans의 첫 값을 1로 초기화한다. 무게는 1부터 시작하기 때문이다.   
추의 무게를 정렬한 후 차례로 더해나가면 ans의 첫값이 1이었으므로 자연스럽게 1 + b가 된다. 즉 현재 측정할 수 없는 무게와 새로 추가할 무게를 비교하는 것이 된다.