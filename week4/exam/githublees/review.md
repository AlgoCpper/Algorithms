### 영단어 암기는 괴로워
1. HashMap을 이용해 단어의 등장하는 횟수를 value에 담는다.
2. 우선순위 큐의 정렬을 Comparator를 사용해 정의하고 key 값인 단어를 넣는다.
3. 큐에 값이 없을 때까지 빼면서 출력한다.

### 가장 큰 정사각형
1. dp를 정의하고 현재 위치에서 위, 왼쪽, 왼쪽 위 대각선 중 하나라도 값이 같지 않다면 정사각형이 될 수 없다.
2. 즉, 현재 위치에서 최대 크기는 위, 왼쪽, 왼쪽 위 대각선 중 가장 작은 값의 +1 이라고 할 수 있다.
3. 이를 점화식으로 풀면 dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i][j-1], dp[i-1][j])) + 1; 이다.
4. 그리고 현재 dp 의 값은 한 변의 길이를 나타내므로 구한 최대값에 *2 를 해줘야한다.

### 센서
1. 구하고자 하는 것은 정확한 길이가 아닌 영역이다.
2. 센서를 정렬하고 각 센서의 거리 차를 배열에 담는다.
3. 이 배열을 내림차순으로 정렬하면 각 센서의 거리 차이가 가장 먼 순서로 정렬된다.
4. 따라서 집중국이 하나 늘어날 때마다 가장 큰 거리의 간격을 제외하여 구하면된다.

### List of Unique Numbers
1. 투포인터를 사용하여 구한다.
2. 핵심 로직은 포함되지 않는 숫자가 있을 때마다 경우의 수는 end - start 이다.
3. end 를 한칸 옆으로 옮기면서 사용되지 않은 숫자라면 사용했다는 표시를 해준 후 end 를 계속 옮겨준다.
4. 만약 end 의 위치한 숫자가 사용한 숫자라면 현재위치에서 end - start를 answer에 더 해준다.
5. 그 후 start를 한칸 옆으로 옮겨주고 사용하지 않는다고 표시해준다.
