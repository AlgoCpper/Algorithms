### 회전초밥
윈도우 슬라이딩 기법으로 풀이.

1. 변수 선언
```java
//회전 초밥 배열
int belt[n];

//먹었다는 것을 표현하기 위한 배열
int sushi[d + 1]; // d는 초밥 가짓수

// 일정 범위 k 안에 있는 초밥 중 중복되지 않게 먹은 갯수
int count;

//쿠폰을 먹었는지 안 먹었는지 구분하기 위한
int eat;
```

2. 처음 범위인 0 부터 k에 대한 초기화 작업
3. for문을 돌면서 윈도우를 벗어난 초밥에 대해서는 sushi[] - 1 줄여준 후 0 이라면 중복되지 않는 초밥이므로 count + 1
4. 윈도우 안으로 들어온 초밥이 먹지 않은 초밥이라면 count + 1 후 일단 범위 안에 들어왔기 때문에 sushi[] + 1
5. 쿠폰으로 먹을 수 있는 초밥을 먹지 않은 상태라면 count + 1, 먹은 상태라면 count 그대로 eat에 넣는다.

---

### 젤다의 전설
1. 최대한 작은 가중치의 값을 가지도록 길을 찾아가야 하므로 다익스트라를 사용하여 풀이
2. 우선순위에 현재 시작 위치 x, y와 루피 값을 넣고 while문을 돈다.
3. 작은 가중치를 얻을 수 있는 곳으로 이동하면서 다른 곳이 더 작은 가중치를 가질 수 있다면 d[][] 값을 갱신한다.

---

### 감시 피하기
1. 조합을 구하는 방식으로 장애물을 맵에 배치시키고 3개의 장애물을 배치했다면 탐색하는 bfs() 함수로 들어간다.
2. 선생님들의 위치를 for문으로 돌면서 S를 만난다면 잘못 설치된 장애물이므로 return false;
3. O를 만난다면 더 이상 바라볼 필요가 없기 때문에 break;(계속 간다면 장애물을 뚫고 탐색을 하기 때문)
4. S를 한번도 만나지 않는다면 정상적으로 장애물을 설치했으므로 true를 리턴하고 출력한다.

---

### 톱니바퀴
1. class로 톱니바퀴를 선언하고 그 톱니바퀴 안에 왼쪽과 오른쪽 붙어있는 기어에 대한 참조 변수를 준다.
2. rotation을 돌면 왼쪽과 오른쪽에도 rotation 함수가 실행되도록 하고 자신을 변수로 넘겨 중복하여 돌지 않도록 한다.
3. 전부 돌았다면 회전 방향으로 배열을 초기화해준다.
