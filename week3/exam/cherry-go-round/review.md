## 문제별 리뷰
### 회전 초밥
이 문제는 슬라이딩 윈도우라고 분류되어있긴 하지만 일반적인 슬라이딩 윈도우 문제와는 다른 점이 있다.   
슬라이딩 윈도우는 공통적인 부분을 두고 새로 추가되는 부분과 필요없는 부분을 더하고 빼서 효과적으로 합을 구하는 방식이다.   
하지만 이 문제는 시작점과 끝점을 정하기는 하지만 시작점부터 끝점까지 매번 탐색을 해야 한다.   
이 문제의 어려운 부분은 원형을 구현하는 부분이다. 처음에는 마지막 원소 뒤에 앞 원소들을 더해야 하나 생각했는데 검색을 통해 % 연산을 사용하면 쉽게 구할 수 있다는 것을 알게 되었다.

<br/>

### 녹색 옷 입은 애가 젤다지?
처음에는 DP로 접근했다. 그런데 두번째 테스트케이스에서 예상과 다른 값이 나왔다. 이 문제는 최단거리로 이동할 필요가 없다. 왼쪽 위에서 오른쪽 아래로 한 방향으로 이동하는 것이 아니라, 위쪽이나 왼쪽으로 다시 돌아갈 수도 있다.   
이 문제는 데이크스트라 알고리즘을 활용해서 풀 수 있다. 정방행렬 모양의 그래프이고, 각 칸의 숫자는 각 node로 들어오는 edge의 가중치로 생각할 수 있다.   
주의해야 할 점은 일반적인 데이크스트라 알고리즘 문제와는 다르게 (0, 0)의 값이 0이 아닐 수도 있다는 점이다. 첫번째 칸에 있는 도둑 루피를 획득하고 시작해야 하기 때문이다.

<br/>

### 감시 피하기
이 문제는 구현이 까다롭지만 어려운 로직이 있지는 않다.   
좌표를 전달받아 사방으로 장애물이 나올 때까지 감시하는 함수를 분리하면 문제를 조금 더 단순하게 만들 수 있다.   
0부터 n * n의 수에서 n으로 나눈 몫과 나머지로 행과 열을 정할 수 있다는 아이디어를 이용하면 백트래킹을 쉽게 구현할 수 있다.

<br/>

### 톱니바퀴
이 문제는 구현 문제다. 톱니바퀴가 동시에 돌아간다는 것을 주의해야 한다. 톱니바퀴를 돌리고 달라진 결과물에 옆 톱니바퀴를 돌리면 안 된다. 그래서 처음에 모든 톱니바퀴의 정보를 알고 있어야 한다. 톱니바퀴마다 옆 톱니바퀴에 전파되는 방식이 다른데, 톱니바퀴가 4개로 고정되어 있으니까 알고리즘을 일반화하지는 않고 단순하게 4개를 따로 구현했다.