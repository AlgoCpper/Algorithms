코드는 짧지만 그렇게 쉽지많은 않은 문제다.

### 첫번째 접근
우선 입출력 예#2를 보고 힌트를 얻었다. 오른쪽 삼각형에서 나올 수 있는 경우의 수를 안다고 가정하고 왼쪽 사다리꼴을 채우는 경우의 수를 생각하는 것이다. 이 때 그림 마지막 줄처럼 오른쪽 삼각형을 침범하면 오른쪽 삼각형의 경우의 수에서 1을 뺀다. 이러면 재귀로 구현할 수 있어 복잡도를 줄일 수 있다. 사다리꼴 윗변에 정삼각형이 있든 말든 크게 달라지는 것은 없다. 정삼각형이 있으면 위로 뻗는 사다리꼴 한 개를 더세면 된다.    
그러나 이런 식으로 구현하면 예상보다 큰 답을 얻게 된다. 왜냐하면 오른쪽 삼각형이 침범당했을 경우에 왼쪽으로 뻗으면서 사다리꼴을 만들 수 없는데 이것까지 셌기 때문이다.   

### 두번째 접근
그렇다면 자연스럽게 삼각형을 침범당하는 경우와 침범당하지 않는 경우를 나눠야 한다는 생각이 든다. 재귀함수의 호출 인자에 삼각형이 침범당했는지를 0과 1로 구분해 넣어주었다.   
테스트 케이스는 모두 통과했으나 제출을 했더니 일부 케이스에서 시간초과가 발생했다. 경우를 나눠 재귀 호출을 했으므로 중복되는 경우가 생긴다는 것을 알아차렸다. dp 방식으로 바꿔 재귀함수를 for문으로 교체했다. 이제 시간 초과가 발생하지 않는다.

### 세번째 접근
시간초과는 발생하지 않으나 여전히 오답처리 된다. 그 이유는 물론 오버플로우 때문이다. 오버플로우 문제가 발생할 것을 알고 있었으나 우선 시간 초과가 발생하지 않을 때까지 외면하고 있었다. dp 테이블을 int형에서 long long으로 바꿨으나 크게 달라지지 않았다. dp 과정에서 long long으로 해결할 수 없을 정도로 매우 큰 수가 나온다는 뜻이다. 곱한 뒤 더하는 과정이 있어 확신할 수 없었으나 매 경우 10007로 나눈 나머지를 구하는 방식으로 바꾸니 정답이 되었다.