## 행운의 문자열
c++ stl의 next_permutation을 이용하면 쉽게 풀 수 있다. 백트래킹으로 모든 경우를 고려하면서 행운의 문자열인지를 체크하면 된다.

## 체인
문제 자체를 이해 못해서 애를 먹었다. 체인의 길이라는 것은 몇 개의 고리가 연결되어 있는지를 나타내는 것이다.   
문제의 핵심은 체인의 길이가 작은 것 부터 열어야 한다는 것이다.   
3 4 5 7 9의 예를 보자. 길이가 3인 체인부터 열면 3개의 고리로 4-5-7-9를 연결할 수 있다.   
그런데 9부터 연다고 하면 3개의 고리로 3-4-5-7을 연결한 후 길이가 6인 체인이 남아있으므로 추가로 고리를 한 개 더 열어서 3-4-5-7-5를 완성시켜야 한다. 즉 고리를 열고나서 '남는' 체인의 개수를 최소화시켜야 하며, 그러려면 체인의 길이가 작은 체인부터 열여야 한다.   
정렬한 후 가장 길이가 가장 작은 체인부터 고리를 하나씩 연다. 고리를 연다는 것은 가장 긴 체인 두 개를 연결하고 가장 작은 길이가 작은 체인의 고리 개수를 하나 줄인다는 뜻이다. 모든 고리를 다 열면 그 다음으로 작은 체인을 열기 시작하면 된다.   
잘 생각해보면, 가장 긴 체인의 길이는 크게 중요하지 않다. 어차피 고리를 여는 것은 가장 작은 체인이고 고리가 추가되는 것은 길이가 가장 긴 체인이기 때문이다. 가장 긴 체인이 두번째로 긴 체인과 합쳐지면 그 체인이 여전히 가장 긴 체인이다. 결국 마지막에 남는 것은 가장 긴 체인 하나기 때문에 그 체인의 길이는 고려하지 않아도 된다는 것이다. 그래서 단순히 가장 긴 체인을 없애주기만 하면 된다. 이럴 때 효율적으로 사용할 수 있는 것은 deque 자료구조이다. deque의 길이가 1이 될 때까지 front 길이를 1씩 줄여주면서 pop_back()하면 된다. 그리고 front의 길이가 1이 되면 front_back()하면 된다.   

## 팰린드롬
매 경우에 팰린드롬을 전부 검사하면 시간 초과가 발생한다.   
팰린드롬을 검사하는 것은 피할 수 없다. 그렇다면 각 질문에서 중복되는 검사를 제외해서 시간을 줄여야 한다는 것이다.   
만약 s + 1번째 수부터 e - 1번째 까지 수가 팰린드롬인지 아닌지를 안다면 s와 e만 비교하면 s번째 수부터 e번째 수가 팰린드롬인지 아닌지를 알 수 있다. 이것은 `pal(s, e) = pal(s + 1)(e - 1) && (num[s] == num[e])`라는 점화식으로 일반화할 수 있다. 이제 dp를 사용할 수 있다. 질문의 상한은 1,000,000가지 이고 n의 상한은 2,000이다. 모두 상한일 때, 겹치지 않는 pal의 수는 s와 e가 같은 경우 2,000가지와 s + 1 == e인 경우 1,999가지를 합해 3,999이다. 비둘기집 원리에 의해 질문 중 겹치는 부분이 반드시 생긴다.   

## 두 동전
아이디어 자체는 간단하다. 두 동전을 동시에 움직이며 bfs하면 된다는 것이다. 그런데 어려운 부분은 한 동전은 움직이지 않고 다른 동전만 움직이는 경우가 있다는 것이다. 두 동전이 동시에 움직이므로 dist 배열을 따로 두는 것보다는 queue에 두 동전이 움직인 거리를 넣고 다니는 것이 좋다. 이렇게 하면 이동 거리가 10을 넘을 경우를 처리하기도 좋다.   
중복 처리를 위해서는 두 동전의 위치를 모두 인덱스로 갖는 `visited[x1][y1][x2][y2]` 배열을 선언한다. 즉 두 동전의 위치가 모두 같은 경우에만 중복이라고 판단하고 진행하지 않는 것이다. 이렇게 해놓고 벽을 만나면 다음 위치를 현재 위치로 바꾸게 하면 큐에서 꺼낸 후 두 동전의 위치가 모두 같은 경우를 거르게 되므로 간단해진다.   
tuple의 경우 {}로 초기화할 수 없고 반드시 make_tuple()을 이용해야 한다는 것에 주의하자. get<>()라는 문법에도 익숙해져야 할 것 같다.